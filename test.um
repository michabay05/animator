fn fade_in*(id: Id, delay: real = 0.0): Action {
    return Action{ ActionKind.FadeIn, delay };
}

fn fade_out*(id: Id, delay: real = 0.0): Action {
    return Action{ ActionKind.FadeOut, delay };
}

fn sleep*(delay: real = 0.0): Action {
    return Action{ ActionKind.Sleep, delay };
}

fn play*(actions: []Action, duration: real = 1.0): void {
    for _, act in actions {
        if act.delay >= duration {
            printf("[WARN] The act below has delay greater than the task duration...\n");
            printf("[WARN] (Duration: %v) vs %v\n", duration, act);
        }
    }

    if task_count < MAX_TASK_COUNT {
        ALL_TASKS[task_count] = Task{ actions, duration };
        task_count++;
    } else {
        printf("[WARN] Can't append any more tasks: going beyond max limit...\n");
    }
}

fn get_task_count(): int {
    return task_count;
}

fn get_tasks(): [MAX_TASK_COUNT]Task {
    return ALL_TASKS;
}


fn sequence(): void {
    r1 := newRect();

    play({fade_in(r1.id, 0.1)});
    play({sleep(1.0)}, 3.1415);
    play({fade_out(r1.id)});
    play({sleep(1.0)}, 3.1415);
}

fn main(): void {
    sequence();
}
